/*
位元\算
C Z言提供了一些 operators，
我能用更低A的方式存取和修改Y料。
@些 operators 包括：
& AND  ( 1&1 = 1。其他都 = 0 )
| OR   ( 1|1 1|0 0|1 都 = 1。0|0 = 0 )
^ XOR  ( 1,1以及0,0 = 0。1,0及0,1 = 1 )
~ NOT(One's complimenta)  ( 1=0。0=1 )
>> Right shift ( ⑽辉向右移 )
<< Left shift  ( ⑽辉向左移 )

@些跟l件判(&&、||)很像，但@些是用在位元\算的operators
*/

/*
譬如：
6: 0110 | ~6:1001
4: 0100 | ~4:1011
--------|
&: 0100 |
|: 0110
^: 0010

*/
#include <stdio.h>
void dispBits(unsigned int val) //int 是32位元，所以用32位
{
    int i;
    /*
    一底x被往左移1位元，原先的位子被填上0
    即一等舯煌左移1，就相於*2
    ex:
    6: 0110
    6 << 1 (6往左移1位元)
    => 1100 = 12
    也就是被*2了
    */
    unsigned int mask = 1 << 31;
    //所以@表示1要乘2 31次，也就是2的31次方
//    10000000000000000000000000000...0000 (310)
//val=00000000000000000000000000000...0110 (val=6)
    for(i=0; i<32; i++)
    {
        if((mask & val) != 0)
        {
            printf("1");
        }
        else
        {
            printf("0");
        }
        mask = mask >> 1; //把1往左移
//    01000000000000000000000000000...0000
//val=00000000000000000000000000000...0110 (val=6)
// &  00000000000000000000000000000...0100
    }
    printf("\n");
}
int main()
{
    dispBits(6);
    dispBits(4);
    dispBits(4 & 6);
    dispBits(4 | 6);
    dispBits(4 ^ 6);

    return 0;
}
