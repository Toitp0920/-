/*
a生子集合
譬如集合中包含 100 200 300 三底
底下的程式a可以a生所有可能的M合
(H排列)
*/
#include <stdio.h>
int mask[16] =
{
    0x00001, 0x00002, 0x00004, 0x00008,
    0x00010, 0x00020, 0x00040, 0x00080,
    0x00100, 0x00200, 0x00400, 0x00800,
    0x01000, 0x02000, 0x04000, 0x08000
};
/*
以上@些都是16M位的底郑每底侄际乔耙底*2
到2M位，分e是：1, 10, 100, 1000, 10000, 100000...
*/
int main(void)
{
    int N, i, j, lim;
    int num[16];

    scanf("%d", &N);
    for (i=0; i<N; i++)
    {
        scanf("%d", &num[i]);
    }
    lim = 1<<N; //1往左移3「bit」，所以lim = 1000 = 8
    for (i=0; i<lim; i++)
    {
        for (j=0; j<N; j++)
        {
            //printf("mask[j] = %d ", mask[j]);
            //printf("i = %d j = %d\n", i, j);
            if ((i&mask[j])!=0)
            {
                printf("%4d", num[j]);
    //i的2M位抵&Mask[j]!=0就是icmaske面b的2M位抵抵辽儆幸位刀际1的r候printf(]一)
    //也就是 i=6=0110 r，mask[2]=0010 cmask[4]=0100
            }
            else printf("  __");
        }
        printf("\n");
    }
    return 0;
}
/*
]一：
i =000 (都不x)
   001 (只x30)
   010 (只x20)
   011 (x20、30)
   100 (只x10)
   101
   110
   111
*/
/*
N = 4 槔
           j= 0            1            2             3
i=0    0000 & 1 ;  0000 & 10 ; 0000 & 100 ; 0000 & 1000
//        0000        0000        0000         0000
i=1    0001 & 1 ;  0001 & 10 ; 0001 & 100 ; 0001 & 1000
//        0001        0000        0000         0000
i=2    0010 & 1 ;  0010 & 10 ; 0010 & 100 ; 0010 & 1000
//        0000        0010        0000         0000
i=3    0011 & 1 ;  0011 & 10 ; 0011 & 100 ; 0011 & 1000
//        0001        0010        0000         0000
i=4    0100 & 1 ;  0100 & 10 ; 0100 & 100 ; 0100 & 1000
//        0000        0000        0100         0000
i=5    0101 & 1 ;  0101 & 10 ; 0101 & 100 ; 0101 & 1000
//        0001        0000        0100         0000
i=6    0110 & 1 ;  0110 & 10 ; 0110 & 100 ; 0110 & 1000
//        0000        0010        0100         0000
i=7    0111 & 1 ;  0111 & 10 ; 0111 & 100 ; 0111 & 1000
//        0001        0010        0100         0000
i=8    1000 & 1 ;  1000 & 10 ; 1000 & 100 ; 1000 & 1000
//        0000        0000        0000         1000
i=9    1001 & 1 ;  1001 & 10 ; 1001 & 100 ; 1001 & 1000
//        0001        0000        0000         1000
i=10   1010 & 1 ;  1010 & 10 ; 1010 & 100 ; 1010 & 1000
//        0000        0010        0000         1000
i=11   1011 & 1 ;  1011 & 10 ; 1011 & 100 ; 1011 & 1000
//        0001        0010        0000         1000
i=12   1100 & 1 ;  1100 & 10 ; 1100 & 100 ; 1100 & 1000
//        0000        0010        0100         1000
i=13   1101 & 1 ;  1101 & 10 ; 1101 & 100 ; 1101 & 1000
//        0001        0000        0100         1000
i=14   1110 & 1 ;  1110 & 10 ; 1110 & 100 ; 1110 & 1000
//        0001        0010        0100         1000
i=15   1111 & 1 ;  1111 & 10 ; 1111 & 100 ; 1111 & 1000
//        0001        0010        0100         1000

*/
